Return-Path: <linux-spi-owner@vger.kernel.org>
X-Original-To: lists+linux-spi@lfdr.de
Delivered-To: lists+linux-spi@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 319375693C9
	for <lists+linux-spi@lfdr.de>; Wed,  6 Jul 2022 23:02:21 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S233884AbiGFVCQ (ORCPT <rfc822;lists+linux-spi@lfdr.de>);
        Wed, 6 Jul 2022 17:02:16 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:33468 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S233456AbiGFVCP (ORCPT
        <rfc822;linux-spi@vger.kernel.org>); Wed, 6 Jul 2022 17:02:15 -0400
Received: from ssl.serverraum.org (ssl.serverraum.org [IPv6:2a01:4f8:151:8464::1:2])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id C926923146;
        Wed,  6 Jul 2022 14:02:14 -0700 (PDT)
Received: from ssl.serverraum.org (web.serverraum.org [172.16.0.2])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by ssl.serverraum.org (Postfix) with ESMTPSA id BABEB2223A;
        Wed,  6 Jul 2022 23:02:12 +0200 (CEST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=walle.cc; s=mail2016061301;
        t=1657141332;
        h=from:from:reply-to:subject:subject:date:date:message-id:message-id:
         to:to:cc:cc:mime-version:mime-version:content-type:content-type:
         content-transfer-encoding:content-transfer-encoding:
         in-reply-to:in-reply-to:references:references;
        bh=l9BSZkguRrgG6EPhutYIDpmenXtzq7TNMD8r/kLbskc=;
        b=WV6CXeZou7RvdPtdmr829rwyfN9tS5+35cTyMXOAxcqfznoaZT/8RuIdbp+P9ggkpqNWH+
        La5o6Jh73TqZrLjKcdw7QVMk4YsHTqNT9+gN1Owvkuh6DIZuy8V4jy7xN4bymULQ73VoM6
        FyvYVXrg8rAbo8PD3ftsNbU1LztRfbk=
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII;
 format=flowed
Content-Transfer-Encoding: 7bit
Date:   Wed, 06 Jul 2022 23:02:12 +0200
From:   Michael Walle <michael@walle.cc>
To:     haibo.chen@nxp.com
Cc:     ashish.kumar@nxp.com, yogeshgaur.83@gmail.com, broonie@kernel.org,
        robh+dt@kernel.org, krzysztof.kozlowski+dt@linaro.org,
        han.xu@nxp.com, singh.kuldeep87k@gmail.com,
        tudor.ambarus@microchip.com, p.yadav@ti.com,
        miquel.raynal@bootlin.com, richard@nod.at, vigneshr@ti.com,
        shawnguo@kernel.org, s.hauer@pengutronix.de, kernel@pengutronix.de,
        linux-spi@vger.kernel.org, linux-kernel@vger.kernel.org,
        devicetree@vger.kernel.org, linux-mtd@lists.infradead.org,
        festevam@gmail.com, linux-imx@nxp.com,
        linux-arm-kernel@lists.infradead.org, zhengxunli@mxic.com.tw
Subject: Re: [PATCH 04/11] spi: spi-nxp-fspi: add function to select sample
 clock source for flash reading
In-Reply-To: <1657012303-6464-4-git-send-email-haibo.chen@nxp.com>
References: <1657012303-6464-1-git-send-email-haibo.chen@nxp.com>
 <1657012303-6464-4-git-send-email-haibo.chen@nxp.com>
User-Agent: Roundcube Webmail/1.4.13
Message-ID: <7a66e4fe8f7224ea272d68276c7b138b@walle.cc>
X-Sender: michael@walle.cc
X-Spam-Status: No, score=-4.4 required=5.0 tests=BAYES_00,DKIM_SIGNED,
        DKIM_VALID,DKIM_VALID_AU,DKIM_VALID_EF,RCVD_IN_DNSWL_MED,SPF_HELO_NONE,
        SPF_PASS,T_SCC_BODY_TEXT_LINE autolearn=ham autolearn_force=no
        version=3.4.6
X-Spam-Checker-Version: SpamAssassin 3.4.6 (2021-04-09) on
        lindbergh.monkeyblade.net
Precedence: bulk
List-ID: <linux-spi.vger.kernel.org>
X-Mailing-List: linux-spi@vger.kernel.org

Am 2022-07-05 11:11, schrieb haibo.chen@nxp.com:
> From: Haibo Chen <haibo.chen@nxp.com>
> 
> fspi define four mode for sample clock source selection.
> 
> Here is the list of modes:
> mode 0: Dummy Read strobe generated by FlexSPI Controller and loopback
> internally
> mode 1: Dummy Read strobe generated by FlexSPI Controller and loopback
> from DQS pad
> mode 2: Reserved
> mode 3: Flash provided Read strobe and input from DQS pad
> 
> In default, fspi use mode 0 after reset.
> For 8-8-8-DTR mode, need to use mode 3, otherwise 8-8-8-DTR read always
> get incorrect data.
> 
> Signed-off-by: Haibo Chen <haibo.chen@nxp.com>
> ---
>  drivers/spi/spi-nxp-fspi.c | 47 ++++++++++++++++++++++++++++++++++++++
>  1 file changed, 47 insertions(+)
> 
> diff --git a/drivers/spi/spi-nxp-fspi.c b/drivers/spi/spi-nxp-fspi.c
> index c32a4f53fa2a..34679dc0e1ad 100644
> --- a/drivers/spi/spi-nxp-fspi.c
> +++ b/drivers/spi/spi-nxp-fspi.c
> @@ -380,6 +380,7 @@ struct nxp_fspi {
>  	struct pm_qos_request pm_qos_req;
>  	int selected;
>  #define FSPI_INITILIZED		(1 << 0)
> +#define FSPI_RXCLKSRC_3		(1 << 1)
>  	int flags;
>  };
> 
> @@ -877,6 +878,50 @@ static int nxp_fspi_do_op(struct nxp_fspi *f,
> const struct spi_mem_op *op)
>  	return err;
>  }
> 
> +/*
> + * Sample Clock source selection for Flash Reading
> + * Four modes defined by fspi:
> + * mode 0: Dummy Read strobe generated by FlexSPI Controller
> + *         and loopback internally
> + * mode 1: Dummy Read strobe generated by FlexSPI Controller
> + *         and loopback from DQS pad
> + * mode 2: Reserved
> + * mode 3: Flash provided Read strobe and input from DQS pad
> + *
> + * fspi default use mode 0 after reset
> + */
> +static void nxp_fspi_select_rx_sample_clk_source(struct nxp_fspi *f,
> +						 const struct spi_mem_op *op)
> +{
> +	u32 reg;
> +
> +	/*
> +	 * For 8-8-8-DTR mode, need to use mode 3 (Flash provided Read
> +	 * strobe and input from DQS pad), otherwise read operaton may
> +	 * meet issue.
> +	 * This mode require flash device connect the DQS pad on board.
> +	 * For other modes, still use mode 0, keep align with before.
> +	 * spi_nor_suspend will disable 8-8-8-DTR mode, also need to
> +	 * change the mode back to mode 0.
> +	 */
> +	if (!(f->flags & FSPI_RXCLKSRC_3) &&
> +			op->cmd.dtr && op->addr.dtr &&
> +			op->dummy.dtr && op->data.dtr) {
> +		reg = fspi_readl(f, f->iobase + FSPI_MCR0);
> +		reg |= FSPI_MCR0_RXCLKSRC(3);
> +		fspi_writel(f, reg, f->iobase + FSPI_MCR0);
> +		f->flags |= FSPI_RXCLKSRC_3;
> +	} else if ((f->flags & FSPI_RXCLKSRC_3) &&
> +			!op->cmd.dtr && !op->addr.dtr &&
> +			!op->dummy.dtr && !op->data.dtr) {
> +		reg = fspi_readl(f, f->iobase + FSPI_MCR0);
> +		reg &= ~FSPI_MCR0_RXCLKSRC(3);	/* select mode 0 */
> +		fspi_writel(f, reg, f->iobase + FSPI_MCR0);
> +		f->flags &= ~FSPI_RXCLKSRC_3;
> +	}

How is this supposed to work? Are you unconditionally enable
flash provided read strobes if DTR is used? What if the
flash doesn't provide one or the board haven't DQS connected?

-michael
